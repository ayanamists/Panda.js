2:"$Sreact.fragment"
3:I[65469,["645","static/chunks/61af6f7f-9cff01d0fc100f98.js","469","static/chunks/469-7ee2e4c850f58403.js","306","static/chunks/306-ef157ce75cbf9e7a.js","827","static/chunks/app/%5Blocale%5D/posts/%5Bslug%5D/page-66612d3f0057dfc7.js"],""]
6:I[39926,["645","static/chunks/61af6f7f-9cff01d0fc100f98.js","469","static/chunks/469-7ee2e4c850f58403.js","306","static/chunks/306-ef157ce75cbf9e7a.js","827","static/chunks/app/%5Blocale%5D/posts/%5Bslug%5D/page-66612d3f0057dfc7.js"],"default"]
a:I[27377,["645","static/chunks/61af6f7f-9cff01d0fc100f98.js","469","static/chunks/469-7ee2e4c850f58403.js","306","static/chunks/306-ef157ce75cbf9e7a.js","827","static/chunks/app/%5Blocale%5D/posts/%5Bslug%5D/page-66612d3f0057dfc7.js"],"default"]
b:I[78703,[],""]
e:I[53751,[],""]
f:I[59576,["706","static/chunks/706-97ed238ee5a03fb5.js","469","static/chunks/469-7ee2e4c850f58403.js","911","static/chunks/911-e9f556f9b03e931c.js","373","static/chunks/373-fbdb9516436dc720.js","203","static/chunks/app/%5Blocale%5D/layout-a565b40c48425316.js"],"Providers"]
4:T1199,<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>next</mtext><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="double-struck">P</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>a</mi><mo>=</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="double-struck">P</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>m</mi><mi mathvariant="normal">∣</mi><mi>m</mi><mo>∈</mo><mi mathvariant="double-struck">P</mi><mo separator="true">,</mo><mi>m</mi><mo>&gt;</mo><mi>a</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>otherwise</mtext></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
\text{next}(a) = \begin{cases}
  \min(\mathbb{P}) &amp; a = \max(\mathbb{P}) \\
  \min(\{ m | m \in \mathbb{P}, m &gt; a \}) &amp; \text{otherwise}
\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">next</span></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mop">min</span><span class="mopen">(</span><span class="mord mathbb">P</span><span class="mclose">)</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mop">min</span><span class="mopen">({</span><span class="mord mathnormal">m</span><span class="mord">∣</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathbb">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">a</span><span class="mclose">})</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord mathbb">P</span><span class="mclose">)</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">otherwise</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>5:T49d,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f(x) = x + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>7:T442,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>∈</mo><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mtext>(len - 1)</mtext><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">j \in [i, \text{(len - 1)}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord">(len - 1)</span></span><span class="mclose">]</span></span></span></span>8:T557,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>&gt;</mo><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">a[j] &gt; a[i - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>9:Tb8c,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>k</mi><mo>≥</mo><mi>i</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>&gt;</mo><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>→</mo><mi>a</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>≥</mo><mi>a</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\forall k \ge i, a[k] &gt; a[i - 1] \to a[k] \ge a[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>c:["locale","zh-cn","d"]
d:["slug","fp-lc100-001-permutation","d"]
0:["sGJvAqyBPtDlNDwp_YH97",[[["",{"children":[["locale","zh-cn","d"],{"children":["posts",{"children":[["slug","fp-lc100-001-permutation","d"],{"children":["__PAGE__?{\"locale\":\"zh-cn\",\"slug\":\"fp-lc100-001-permutation\"}",{}]}]}]}]},"$undefined","$undefined",true],["",{"children":[["locale","zh-cn","d"],{"children":["posts",{"children":[["slug","fp-lc100-001-permutation","d"],{"children":["__PAGE__",{},[["$L1",["$","article",null,{"children":[["$","h1",null,{"className":"text-4xl font-bold mb-2","children":"函数式 Leetcode 百题 -- 排列"}],["$","div",null,{"className":"text-sm text-gray-500 mb-5","children":"4/24/2024"}],["$","$2","0",{"children":[["$","div",null,{"className":"toc","id":"toc","children":[["$","ul","0",{"children":[["$","li","0",{"children":[["$","a","0",{"href":"#前言","id":"toc-前言","children":["前言"]}]]}],["$","li","1",{"children":[["$","a","0",{"href":"#下一个排列","id":"toc-下一个排列","children":["31."," ","下一个排列"]}],["$","ul","1",{"children":[["$","li","0",{"children":[["$","a","0",{"href":"#题目描述","id":"toc-题目描述","children":["题目描述"]}]]}],["$","li","1",{"children":[["$","a","0",{"href":"#第一想法","id":"toc-第一想法","children":["第一想法"]}]]}],["$","li","2",{"children":[["$","a","0",{"href":"#递归","id":"toc-递归","children":["递归"]}]]}],["$","li","3",{"children":[["$","a","0",{"href":"#ismax-的定义","id":"toc-ismax-的定义","children":[["$","code","0",{"children":["isMax"]}]," ","的定义"]}]]}],["$","li","4",{"children":[["$","a","0",{"href":"#tick-的定义","id":"toc-tick-的定义","children":[["$","code","0",{"children":["tick"]}]," ","的定义"]}]]}],["$","li","5",{"children":[["$","a","0",{"href":"#更高效的代码","id":"toc-更高效的代码","children":["更高效的代码"]}]]}],["$","li","6",{"children":[["$","a","0",{"href":"#总结","id":"toc-总结","children":["总结"]}]]}]]}]]}]]}]]}],["$","h2",null,{"className":"text-3xl","id":"前言","children":[["$","$L3",null,{"href":"#前言","color":"secondary","className":"pr-3 no-underline hover:underline","children":"#"}],["前言"]]}],["$","p",null,{"children":["算法题，是很多程序员的梦魇之一。算法本身当然是有趣的，但不会做题的抓狂、面试回答不出问题的窘迫，没有人会喜欢。"]}],["$","p",null,{"children":["应对算法题挑战的传统方式是"," ",["$","strong","0",{"children":["刷题"]}]," ","。"," ","刷题，也就是做大量的题目来学习算法。很多人笃信一种理论，无论是数学学习还是算法学习，都必须进行大量的练习。"]}],["$","p",null,{"children":["我也认同这种理论。冯诺依曼的箴言还挂在本博客的首页上："]}],["$","blockquote","5",{"children":[["$","p",null,{"children":["Young"," ","man,"," ","in"," ","mathematics"," ","you"," ","don’t"," ","understand"," ","things."," ","You"," ","just"," ","get"," ","used"," ","to"," ","them."]}]]}],["$","p",null,{"children":["直觉的认识，直觉的经验，是无比宝贵的财富。练习是获取这种宝贵财富最可靠的手段。简而言之，想要学习算法，你必须刷题，必须练习。"]}],["$","p",null,{"children":["然而，我确实极度厌烦一种算法学习的常规路径。那就是看到某道题不会做，思考了"," ","10"," ","分钟还是不知道从何入手，那么就去寻找答案。也许你"," ",["$","q","0",{"children":["理解"]}]," ","了答案或者记住了答案，下次看到相同的题目的时候就套进去。只要你见过的答案够多，那么你能"," ",["$","q","1",{"children":["套"]}]," ","的题目也够多。"]}],["$","p",null,{"children":["为什么我不喜欢这种学习方法呢？也许是我不够聪明吧，我很难"," ",["$","q","0",{"children":["理解"]}]," ","别人给的答案。太多的人只是把最后的高效算法告诉你，而忽略了直觉建立的过程，更别提算法的证明了。从这些人的答案里，我既没有感受到他们对于问题的深刻理解，又没有感受到算法本身的美感。"]}],["$","p",null,{"children":["难道我们只能通过给"," ",["$","q","0",{"children":["天才"]}]," ","设计的教育来学习算法吗？"]}],["$","p",null,{"children":["不。世界上还有一群人，在尝试着用纯函数式的语言，用等式推导的方法来设计程序。这些人同样也珍视直觉的价值。他们会从一个清晰而不高效的程序出发，一步步地给出最终的高效算法。在这个过程中，算法的美、算法的"," ","insight"," ","纤毫毕现。已故的"," ","Richard"," ","Bird，台湾的穆信成老师都是这种方式的先驱。在他们的论文和书籍中，我感受到了一种真正的温柔。"]}],["$","p",null,{"children":["我想，虽然等式推导很多时候非常困难，但是把算法的"," ","non-trivial"," ","之处是什么、算法的直觉是什么讲清楚，也许没有那么困难。"]}],["$","p",null,{"children":["本系列文章就是我的尝试。我将在这些文章中，讲解我是怎么用纯函数式编程解决"," ","Leetcode"," ","的。至于为什么选择"," ","Leetcode"," ","而不是难度更高的"," ","Codeforces，我认为难度太高，也许不是好事。高难度的问题很可能需要多个算法共同来处理，而我们更想在每篇文章中关注某类具体的算法。（另一个原因是，我本人对于算法仍然是某种意义的"," ",["$","q","0",{"children":["初学者"]}],"，难度太高我也处理不来）"]}],["$","p",null,{"children":["选择"," ","Leetcode"," ","的一个后果是，我们必须用"," ","Racket"," ","或者"," ","Scala"," ","而非"," ","Haskell"," ","来提交代码。这有时候会造成一些困扰，不过我的经验是，大部分我给出的"," ","Haskell"," ","代码可以直接翻译到"," ","Scala"," ","上。每道题目我也会给出对应的"," ","Scala"," ","解。如果确实有问题，比如"," ","Scala"," ","没有"," ",["$","code","0",{"children":["Data.Graph"]}]," ","这种不可变数据结构库，那么我们会视情况退回到非纯函数式编程。不过，这种情况总体应该是较少的。在每道题目的最后，我可能也会把对应的命令式版本给出，也许我们还会探讨一下函数式版本和命令式版本的区别。"]}],["$","p",null,{"children":["这些文章不是"," ",["$","q","0",{"children":["函数式编程入门"]}],"。虽然我也许会提示某个库函数的用法，但是总体来说，这些文章假设你已经有了纯函数式编程的基本知识"," ","–"," ","递归，列表，fold，map"," ","等等。如果你对函数式编程和"," ","Haskell"," ","语言一无所知，那么在阅读这些文章之前最好简单学习一些"," ","Haskell"," ","知识。以下是我比较推荐的学习资源："]}],["$","ul","15",{"children":[["$","li","0",{"children":[["$","a","0",{"href":"https://www.seas.upenn.edu/~cis1940/spring13/lectures.html","children":["cis194"," ","课程"]}]]}],["$","li","1",{"children":[["$","em","0",{"children":["Thinking"," ","Functionally"," ","With"," ","Haskell"]}],"，以及其中文翻译版本"," ",["$","a","1",{"href":"https://book.douban.com/subject/26769112/","children":["Haskell函数式程序设计"]}]]}],["$","li","2",{"children":["练习是重要的，可以通过"," ",["$","a","0",{"href":"https://wiki.haskell.org/99_questions/1_to_10","children":["Haskell"," ","99"," ","题"]}]," ","进行练习。这些练习和"," ","Leetcode"," ","不同，大部分通过直接的递归就可以完成"]}]]}],["$","blockquote","16",{"children":[["$","p",null,{"children":["路漫漫其修远兮，吾将上下而求索"]}]]}],["$","h2",null,{"className":"text-3xl","id":"下一个排列","children":[["$","$L3",null,{"href":"#下一个排列","color":"secondary","className":"pr-3 no-underline hover:underline","children":"#"}],["31."," ","下一个排列"]]}],["$","h3",null,{"className":"text-2xl","id":"题目描述","children":[["$","$L3",null,{"href":"#题目描述","color":"secondary","className":"pr-3 no-underline hover:underline","children":"#"}],["题目描述"]]}],["$","p",null,{"children":["以下是"," ",["$","a","0",{"href":"https://leetcode.cn/problems/next-permutation/","children":["Leetcode"]}]," ","的原始描述："]}],["$","blockquote","20",{"children":[["$","p",null,{"children":["整数数组的一个"," ",["$","strong","0",{"children":["排列"]}]," ","就是将其所有成员以序列或线性顺序排列。"]}],["$","p",null,{"children":["例如，",["$","code","0",{"children":["arr = [1,2,3]"]}]," ","，以下这些都可以视作"," ",["$","code","1",{"children":["arr"]}]," ","的排列：",["$","code","2",{"children":["[1,2,3]"]}],"、",["$","code","3",{"children":["[1,3,2]"]}],"、`",["$","code","4",{"children":["[3,1,2]"]}],"、",["$","code","5",{"children":["[2,3,1]"]}]," ","。"," ","整数数组的"," ","下一个排列"," ","是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的"," ","下一个排列"," ","就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。"]}],["$","p",null,{"children":["例如，",["$","code","0",{"children":["arr = [1,2,3]"]}]," ","的下一个排列是"," ",["$","code","1",{"children":["[1,3,2]"]}]," ","。"," ","类似地，",["$","code","2",{"children":["arr = [2,3,1]"]}]," ","的下一个排列是"," ",["$","code","3",{"children":["[3,1,2]"]}]," ","。"," ","而"," ",["$","code","4",{"children":["arr = [3,2,1]"]}]," ","的下一个排列是"," ",["$","code","5",{"children":["[1,2,3]"]}]," ","，因为"," ",["$","code","6",{"children":["[3,2,1]"]}]," ","不存在一个字典序更大的排列。"," ","给你一个整数数组"," ",["$","code","7",{"children":["nums"]}]," ","，找出"," ",["$","code","8",{"children":["nums"]}]," ","的下一个排列。"]}],["$","p",null,{"children":["必须"," ","原地"," ","修改，只允许使用额外常数空间。"]}]]}],["$","p",null,{"children":["我们是在纯函数式编程。纯函数式编程没有所谓的"," ",["$","q","0",{"children":["修改"]}],"，所以最后一句话我们无视即可。"]}],["$","h3",null,{"className":"text-2xl","id":"第一想法","children":[["$","$L3",null,{"href":"#第一想法","color":"secondary","className":"pr-3 no-underline hover:underline","children":"#"}],["第一想法"]]}],["$","p",null,{"children":["一般来说，很多算法问题能够给一个极为简洁（但低效）的纯函数式解。我们把这个解称之为程序的标准参照（Spec），我们的思考也从这里出发。然而，这个问题却似乎不是这种情况。考虑这个问题的数学表达："]}],["$","div",null,{"children":[["$","div",null,{"className":"overflow-auto","children":["$","div",null,{"data-testid":"react-katex","dangerouslySetInnerHTML":{"__html":"$4"}}]}]]}],["$","p",null,{"children":["这没有给我们多少灵感。事实上，在很多编程语言里，把"," ",["$","span",null,{"data-testid":"react-katex","dangerouslySetInnerHTML":{"__html":"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">P</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{P}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">P</span></span></span></span>"}}],"，也就是某个列表的所有排列求出来，比这个问题还要麻烦。"]}],["$","p",null,{"children":["这种情况下，一个直觉的尝试是，",["$","strong","0",{"children":["简单的递归"]}]," ","能不能解决问题呢？"]}],["$","h3",null,{"className":"text-2xl","id":"递归","children":[["$","$L3",null,{"href":"#递归","color":"secondary","className":"pr-3 no-underline hover:underline","children":"#"}],["递归"]]}],["$","p",null,{"children":["十进制整数可以被表示为一个列表。某些人把它叫做"," ",["$","q","0",{"children":["高精度"]}]," ","算法。例如，你可以用"," ",["$","code","1",{"children":["[1, 0, 0]"]}]," ","表示"," ",["$","span",null,{"data-testid":"react-katex","dangerouslySetInnerHTML":{"__html":"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>100</mn></mrow><annotation encoding=\"application/x-tex\">100</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">100</span></span></span></span>"}}]," ","."," ","这种表示的好处是，整数"," ",["$","span",null,{"data-testid":"react-katex","dangerouslySetInnerHTML":{"__html":"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span>"}}],","," ",["$","span",null,{"data-testid":"react-katex","dangerouslySetInnerHTML":{"__html":"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span>"}}],"，"," ",["$","span",null,{"data-testid":"react-katex","dangerouslySetInnerHTML":{"__html":"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>≥</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a \\ge b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span>"}}]," ","当且仅当"," ",["$","code","6",{"children":["a >= b"]}],"，其中"," ",["$","code","7",{"children":[">="]}]," ","恰恰就是字典序比较。"]}],["$","p",null,{"children":["显然地，十进制整数也可以定义"," ",["$","code","0",{"children":["next"]}]," ","函数。这就是大名鼎鼎的"," ",["$","q","1",{"children":["后继"]}]," ","函数，即"," ",["$","span",null,{"data-testid":"react-katex","dangerouslySetInnerHTML":{"__html":"$5"}}]," ",","," ","我们把这个函数记作"," ",["$","code","3",{"children":["next10"]}],"."]}],["$","$L6","30",{"className":"haskell","children":["-- next10 [1, 1, 0] = [1, 1, 1]\nnext10 ..."]}],["$","p",null,{"children":["这确实给了我们一些灵感。例如，",["$","code","0",{"children":["next10 [1, 1, 0] = [1, 1, 1]"]}],"，这是因为"," ",["$","code","1",{"children":["next [1, 0] = [1, 1]"]}],"."," ","可以很明显地看到这里的递归关系。具体来说，对于"," ",["$","code","2",{"children":["x:xs"]}]," ","表示的整数，"]}],["$","$L6","32",{"className":"haskell","children":["next10 (x:xs) = x:(next10 xs)"]}],["$","p",null,{"children":["上面的等式在大部分时候都成立。除非，",["$","code","0",{"children":["next10 xs"]}]," ","已经"," ",["$","q","1",{"children":["求不出来了"]}],"，比如"," ",["$","code","2",{"children":["[1, 9, 9]"]}]," ","的下一个数字（后继）是"," ",["$","code","3",{"children":["[2, 0, 0]"]}],"，这时就必须要"," ",["$","q","4",{"children":["进位"]}],"。更严格地说，",["$","code","5",{"children":["99"]}]," ","是"," ",["$","strong","6",{"children":["最大"]}]," ","的两位十进制整数，所以上面的等式不成立。只要"," ",["$","code","7",{"children":["xs"]}]," ","还不是最大值，那么上面的等式就成立。"]}],["$","p",null,{"children":["无独有偶，题目要求的"," ",["$","code","0",{"children":["next"]}]," ","函数具有同样的性质。根据这个想法，构造递归函数："]}],["$","$L6","35",{"className":"haskell","children":["next (x:xs)\n    | isMax xs  = tick x xs\n    | otherwise = x:next xs"]}],["$","p",null,{"children":["那么，问题就变成了"]}],["$","ol","37",{"children":[["$","li","0",{"children":["如何定义"," ",["$","code","0",{"children":["isMax"]}]]}],["$","li","1",{"children":["如果"," ",["$","code","0",{"children":["xs"]}]," ","已经是最大值了，那么"," ",["$","code","1",{"children":["tick"]}]," ","函数该怎么定义呢？"]}]]}],["$","h3",null,{"className":"text-2xl","id":"ismax-的定义","children":[["$","$L3",null,{"href":"#ismax-的定义","color":"secondary","className":"pr-3 no-underline hover:underline","children":"#"}],[["$","code","0",{"children":["isMax"]}]," ","的定义"]]}],["$","p",null,{"children":["对于一个排列"," ",["$","code","0",{"children":["xs"]}]," ","来说，",["$","q","1",{"children":["最大"]}]," ","就是说，无论怎么重新排列，新的"," ",["$","code","2",{"children":["xs'"]}]," ","一定有"," ",["$","code","3",{"children":["xs >= xs'"]}],"."]}],["$","p",null,{"children":["什么样的排列具有这种性质呢？一个很自然的想法是，因为这是字典序，所以如果想要排列尽可能大，那就一定要把大的数放在前面。换句话说，",["$","q","0",{"children":["降序"]}]," ","的排列一定是最大的。"]}],["$","$L6","41",{"className":"haskell","children":["isMax :: Ord a => [a] -> Bool\nisMax = down"]}],["$","p",null,{"children":["在"," ","Haskell"," ","里，判断一个列表的升降，我们可以使用"," ",["$","q","0",{"children":["zip"," ","with"," ","tail"]}]," ","的方法。具体来说，就是首先把列表和它的"," ",["$","code","1",{"children":["tail"]}]," ","进行"," ",["$","code","2",{"children":["zip"]}],"，然后再使用"," ",["$","code","3",{"children":["map"]}],","," ",["$","code","4",{"children":["all"]}]," ","之类的函数来判断。"]}],["$","$L6","43",{"className":"haskell","children":["dup :: [a] -> [(a, a)]\ndup xs = zip xs (tail xs)\n\ndown :: Ord a => [a] -> Bool\ndown = all (uncurry (>=)) . dup"]}],["$","h3",null,{"className":"text-2xl","id":"tick-的定义","children":[["$","$L3",null,{"href":"#tick-的定义","color":"secondary","className":"pr-3 no-underline hover:underline","children":"#"}],[["$","code","0",{"children":["tick"]}]," ","的定义"]]}],["$","p",null,{"children":["如果"," ",["$","code","0",{"children":["xs"]}]," ","已经满足了"," ",["$","code","1",{"children":["down"]}],"，换言之，它已经是最大的了，那么"," ",["$","code","2",{"children":["x:xs"]}]," ","必须要进行比较复杂的操作才能得到下一个枚举。这个复杂的操作，被我称为"," ",["$","code","3",{"children":["tick"]}],"."]}],["$","p",null,{"children":["例如，",["$","code","0",{"children":["[2, 4, 3, 1]"]}]," ","的下一个枚举是"," ",["$","code","1",{"children":["[3, 1, 2, 4]"]}],"."," ","这时"," ",["$","code","2",{"children":["x"]}]," ","是"," ",["$","code","3",{"children":["2"]}],","," ",["$","code","4",{"children":["xs"]}]," ","是"," ",["$","code","5",{"children":["[4, 3, 1]"]}],"，",["$","code","6",{"children":["xs"]}]," ","满足"," ",["$","code","7",{"children":["down"]}],"，所以，这时不能再进行简单的递归，而要用"," ",["$","code","8",{"children":["tick"]}]," ","进行计算。"]}],["$","p",null,{"children":["继续以"," ",["$","code","0",{"children":["[2, 4, 3, 1]"]}]," ","为例。直觉上来讲，要求"," ",["$","code","1",{"children":["[2, 4, 3, 1]"]}]," ","的下一个枚举"," ",["$","code","2",{"children":["ys@(y:ys')"]}],","," ","可以分为两步："]}],["$","ul","48",{"children":[["$","li","0",{"children":["确定"," ",["$","code","0",{"children":["y"]}]," ","是什么"]}],["$","li","1",{"children":["确定"," ",["$","code","0",{"children":["ys'"]}]," ","是什么"]}]]}],["$","p",null,{"children":["首先，",["$","code","0",{"children":["y"]}]," ","要严格大于"," ",["$","code","1",{"children":["x"]}],"."," ","因为我们已经表明，所有以"," ",["$","code","2",{"children":["x"]}]," ","开头的枚举都要比"," ",["$","code","3",{"children":["x:xs"]}]," ","小。其次，",["$","code","4",{"children":["y"]}]," ","要尽可能小，不然会有更小的枚举"," ",["$","code","5",{"children":["p"]}]," ","满足"," ",["$","code","6",{"children":["p > x:xs"]}],"."]}],["$","p",null,{"children":["上例中"," ",["$","code","0",{"children":["y"]}]," ","是"," ",["$","code","1",{"children":["3"]}],"."," ","很容易想到，",["$","code","2",{"children":["3"]}]," ","是"," ",["$","code","3",{"children":["xs = [4, 3, 1]"]}]," ","中，",["$","strong","4",{"children":["最小的"]}]," ","大于"," ",["$","code","5",{"children":["x = 2"]}]," ","的数。我们把这种数叫做"," ",["$","code","6",{"children":["pivot"]}],"."," ","可以写出定义代码："]}],["$","$L6","51",{"className":"haskell","children":["pivot x xs = minumum [ x' | x' <- xs, x' > x  ]"]}],["$","p",null,{"children":["注意到"," ",["$","code","0",{"children":["xs"]}]," ","是有序的，以上代码可以改写为"]}],["$","$L6","53",{"className":"haskell","children":["pivot x = last . takeWhile (> x)"]}],["$","p",null,{"children":["需要指出的是，",["$","code","0",{"children":["pivot"]}]," ","函数是一个偏函数，我们用了不安全的"," ",["$","code","1",{"children":["last"]}]," ","和"," ",["$","code","2",{"children":["minimum"]}]," ","操作，这意味着在调用时，必须保证至少存在一个"," ",["$","code","3",{"children":["x' > x"]}],"."]}],["$","p",null,{"children":["如果能够找到这样的"," ",["$","code","0",{"children":["y > x"]}],"，那么我们就可以保证，",["$","code","1",{"children":["y:ys'"]}]," ","绝对比"," ",["$","code","2",{"children":["x:xs"]}]," ","大。所以，",["$","code","3",{"children":["ys'"]}]," ","的构造要使得"," ",["$","code","4",{"children":["y:ys'"]}]," ","尽可能小。也就是说，",["$","code","5",{"children":["ys'"]}]," ","应该是最小的一个排列。和我们上面对于最大值的讨论一样，最小的排列就是单调递增的排列。这只需要排序即可。"]}],["$","p",null,{"children":[["$","code","0",{"children":["ys'"]}]," ","中的元素自然是"," ",["$","code","1",{"children":["xs"]}]," ","除掉"," ",["$","code","2",{"children":["y"]}]," ","之后，再加上"," ",["$","code","3",{"children":["x"]}],"."," ","例如，上面的例子"," ",["$","code","4",{"children":["[2, 4, 3, 1]"]}],"，可以给出"]}],["$","$L6","57",{"className":"haskell","children":["x:xs = [2, 4, 3, 1]\n\ny = last . takeWhile (> x) $ xs\n  = last [4, 3]\n  = 3\n\nys'' = delete 3 xs\n     = [4, 1]\n\nys' = sort (x:ys'')\n    = sort [2, 4, 1]\n    = [1, 2, 4]\n\nys = y:ys'\n   = [3, 1, 2, 4]"]}],["$","p",null,{"children":["最后，还需要讨论一种情况，那就是"," ",["$","code","0",{"children":["pivot x xs = ⊥"]}],"."," ","这种情况必须先行判断，以免出现错误。什么时候"," ",["$","code","1",{"children":["pivot"]}]," ","不存在呢？那就是"," ",["$","code","2",{"children":["x:xs"]}]," ","已经满足"," ",["$","code","3",{"children":["down"]}]," ","的时候，例如"," ",["$","code","4",{"children":["[4, 3, 2, 1]"]}],"，这种时候，只需要把输入反转即可。"]}],["$","p",null,{"children":["根据以上讨论，我们给出"," ",["$","code","0",{"children":["tick"]}]," ","函数的定义："]}],["$","$L6","60",{"className":"haskell","children":["import Data.List (delete)\n\ntick :: Ord a -> a -> [a] -> [a]\ntick x xs\n    | null l    = reverse (x:xs)\n    | otherwise = y:(sort (x:ys'))\n    where l = takeWhile (> x) xs\n          y = last l\n          ys' = delete y xs"]}],["$","$L6","61",{"className":"haskell","children":["> tick 4 [3, 2, 1]\n[1, 2, 3, 4]\n\n> tick 2 [4, 3, 1]\n[3, 1, 2, 4]"]}],["$","p",null,{"children":["毫无疑问，目前的"," ",["$","code","0",{"children":["next"]}]," ","函数已经能够正确地解决这个问题了。读者不妨把以上的"," ","Haskell"," ","代码翻译为"," ","Scala，在"," ","Leetcode"," ","里试一试。从递归出发，我们发现这个问题的解非常直觉，可以简单而轻松地给出。"]}],["$","h3",null,{"className":"text-2xl","id":"更高效的代码","children":[["$","$L3",null,{"href":"#更高效的代码","color":"secondary","className":"pr-3 no-underline hover:underline","children":"#"}],["更高效的代码"]]}],["$","p",null,{"children":["上面定义的"," ",["$","code","0",{"children":["next"]}]," ","函数虽然优雅直观，但是不够高效。主要的问题在于，"]}],["$","ol","65",{"children":[["$","li","0",{"children":[["$","code","0",{"children":["tick"]}]," ","中，不需要用到"," ",["$","code","1",{"children":["sort"]}],"."," ",["$","code","2",{"children":["xs"]}]," ","是有序的，可以利用这点在"," ",["$","span",null,{"data-testid":"react-katex","dangerouslySetInnerHTML":{"__html":"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>"}}]," ","内把新的有序序列组合起来"]}],["$","li","1",{"children":[["$","code","0",{"children":["down"]}]," ","被"," ",["$","code","1",{"children":["next"]}]," ","调用了好多次，每次调用都是"," ",["$","span",null,{"data-testid":"react-katex","dangerouslySetInnerHTML":{"__html":"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>"}}]," ","的，导致总体复杂度出现了"," ",["$","span",null,{"data-testid":"react-katex","dangerouslySetInnerHTML":{"__html":"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>"}}],"."]}]]}],["$","p",null,{"children":["问题"," ","1."," ","很简单，只需要重新写一下"," ",["$","code","0",{"children":["tick"]}]," ","即可。"]}],["$","p",null,{"children":["问题"," ","2."," ","比较麻烦。我们需要仔细观查一下计算的过程，例如"," ",["$","code","0",{"children":["next [3, 5, 1, 4, 2]"]}],"："]}],["$","$L6","68",{"className":"haskell","children":["next [3, 5, 1, 4, 2]\n= 3:(next [5, 1, 4, 2])\n= 3:(5:(next [1, 4, 2]))\n= 3:(5:(tick 1 [4, 2]))"]}],["$","p",null,{"children":["可以看到，这个计算总是会具有一种"," ",["$","q","0",{"children":["形状"]}],"，那就是输入的前一部分保持不变，后一部分被"," ",["$","code","1",{"children":["tick"]}],"."]}],["$","$L6","70",{"className":"haskell","children":["[3, 5,           1, 4, 2]\n^^^^^^           #######\n保持不变的部分     tick 的部分"]}],["$","p",null,{"children":["而它们的分界线，直觉上来讲，就是"," ",["$","code","0",{"children":["down"]}]," ","由"," ",["$","code","1",{"children":["False"]}]," ","变为"," ",["$","code","2",{"children":["True"]}]," ","的时刻。我们再回到"," ",["$","code","3",{"children":["next"]}]," ","函数："]}],["$","$L6","72",{"className":"haskell","children":["next (x:xs)\n    | down xs  = tick x xs\n    | otherwise = x:next xs"]}],["$","p",null,{"children":["在每次递归的时候，",["$","code","0",{"children":["next (x:xs)"]}]," ","都会计算"," ",["$","code","1",{"children":["down xs"]}],"，再用刚才的例子，"]}],["$","$L6","74",{"className":"haskell","children":["-- 第一次递归\ndown [5, 1, 4, 2] = False\n-- 第二次递归\ndown [1, 4, 2]    = False\n-- 第三次递归\ndown [4, 2]       = True"]}],["$","p",null,{"children":["事实上，",["$","code","0",{"children":["down"]}]," ","每次都顺序地计算"," ",["$","code","1",{"children":["tails"]}]," ","里的下一个元素："]}],["$","$L6","76",{"className":"haskell","children":["> tails [3, 5, 1, 4, 2]\n[[3,5,1,4,2],[5,1,4,2],[1,4,2],[4,2],[2],[]]"]}],["$","p",null,{"children":["不妨把"," ",["$","code","0",{"children":["next"]}]," ","每次用到的"," ",["$","code","1",{"children":["down xs"]}]," ","提前",["$","sup","2",{"children":[["$","a","0",{"href":"#note-1","id":"note-anchor-1","children":["1"]}]]}],"算出来，并放到一个列表里"]}],["$","$L6","78",{"className":"haskell","children":["import Data.List (tails)\n\nnextDown (x:xs) (d:ds)\n    | d = tick x xs\n    | otherwise = x:nextDown xs ds\n\nnext xs = nextDown xs (downs xs)\ndowns = drop 1 . map down . tails"]}],["$","p",null,{"children":["如果我们可以在"," ",["$","span",null,{"data-testid":"react-katex","dangerouslySetInnerHTML":{"__html":"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>"}}]," ","时间内算出"," ",["$","code","1",{"children":["downs"]}],"，问题"," ","2."," ","就迎刃而解了。直觉上来说，这是很容易的，因为"," ",["$","code","2",{"children":["down [4, 3, 2, 1]"]}]," ","本来就是要保证："]}],["$","ul","80",{"children":[["$","li","0",{"children":[["$","code","0",{"children":["4 >= 3"]}]]}],["$","li","1",{"children":[["$","code","0",{"children":["down [3, 2, 1]"]}]]}]]}],["$","p",null,{"children":["换句话说，当我们要算"," ",["$","code","0",{"children":["down [4, 3, 2, 1]"]}]," ","的时候，",["$","code","1",{"children":["down [3, 2, 1]"]}]," ","已经被计算过了，只是需要一种方式把这种"," ",["$","q","2",{"children":["上一次的计算"]}]," ","存起来以便后续使用。"]}],["$","p",null,{"children":["函数式编程社区早就有了对于这种问题的解决方法："," ","scan"," ","theorem."]}],["$","p",null,{"children":["Scan"," ","theorem"," ","指的是"]}],["$","$L6","84",{"className":"haskell","children":["map (foldl op a) . inits = scanl op a"]}],["$","p",null,{"children":["类似地"]}],["$","$L6","86",{"className":"haskell","children":["map (foldr op a) . tails = scanr op a"]}],["$","p",null,{"children":["利用这个定理，我们给出以下程序计算过程."," ","注意，为了避免问题，我们定义了"]}],["$","$L6","88",{"className":"haskell","children":["tails' = filter (not . null) . tails"]}],["$","$L6","89",{"className":"haskell","children":["downs = { definition }\n        drop 1 . map down . tails'\n      = { definition }\n        drop 1 . map (all (uncurry (>=)) . dup) . tails'\n      = { map distributivity }\n        drop 1 . map (all (uncurry (>=))) . map dup . tails'\n      = { need another proof (1) }\n        drop 1 . map (all (uncurry (>=))) . tails . dup\n      = { definition }\n        drop 1 . map (foldr (&&) True . map (uncurry (>=))) . tails . dup\n      = { fold-map fusion }\n        drop 1 . map (foldr join True) . tails . dup\n      = { scan theorem }\n        drop 1 . scanr join True . dup\n          where join (x, x1) r = x >= x1 && r"]}],["$","ol","90",{"children":[["$","li","0",{"children":["需要一个新的证明，它指的是下面的代码是等价的："]}]]}],["$","$L6","91",{"className":"haskell","children":["> map dup $ tails' [4, 2, 3, 1]\n[[(4,2),(2,3),(3,1)],[(2,3),(3,1)],[(3,1)],[]]\n\n> tails $ dup [4, 2, 3, 1]\n[[(4,2),(2,3),(3,1)],[(2,3),(3,1)],[(3,1)],[]]"]}],["$","p",null,{"children":["证明略去。"]}],["$","h3",null,{"className":"text-2xl","id":"总结","children":[["$","$L3",null,{"href":"#总结","color":"secondary","className":"pr-3 no-underline hover:underline","children":"#"}],["总结"]]}],["$","p",null,{"children":["结合上面的讨论，我们可以给出高效的函数式实现："]}],["$","$L6","95",{"className":"haskell","children":["tick x xs = build l r x\n    where (l, r) = span (> x) xs\n          build [] r x = reverse (x:r)\n          build l  r x = last l : reverse (init l ++ [x] ++ r)\n\ndup xs = zip xs (tail xs)\ndowns = scanr (\\(x, x1) r -> (x >= x1) && r) True . dup\n\nnext xs = l ++ tick (head r) (tail r)\n    where (l, r) = splitAt (n - 1) xs\n          n = length $ takeWhile not $ downs xs"]}],["$","p",null,{"children":["这是"," ",["$","span",null,{"data-testid":"react-katex","dangerouslySetInnerHTML":{"__html":"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>"}}]," ","时间复杂度的。不过，我们的常数确实会比命令式程序大些。理论上来说，上一节定义的"," ",["$","code","1",{"children":["nextDown"]}]," ","函数的实现要更高效一些（避免了"," ",["$","code","2",{"children":["length"]}]," ","和"," ",["$","code","3",{"children":["splitAt"]}],"），但是我仍然觉得本节给出的实现更清楚。"]}],["$","p",null,{"children":["我把等价的"," ","Scala"," ","代码提交到了"," ","leetcode:"]}],["$","$L6","98",{"className":"scala","children":["object Solution {\n    def nextPermutation(nums: Array[Int]): Unit = {\n        val nextNums = next(nums.toList).toArray\n        for (i <- nums.indices) {\n            nums(i) = nextNums(i)\n        }\n    }\n\n    def dup(xs: List[Int]): List[(Int, Int)] = xs zip xs.drop(1)\n\n    def tick(x: Int, xs: List[Int]): List[Int] = {\n        val (l, r) = xs.span(_ > x)\n        if (l.isEmpty) r.reverse ++ List(x)\n        else l.last :: (l.init ++ List(x) ++ r).reverse\n    }\n\n    def tailsDown(xs: List[(Int, Int)]): List[Boolean] = \n        xs.scanRight(true) { case ((x, x1), r) => (x >= x1) && r }\n\n    def next(xs: List[Int]): List[Int] = {\n        val n = tailsDown(dup(xs)).takeWhile(!_).length\n        val (l, r) = xs.splitAt(n - 1)\n        l ++ tick(r.head, r.tail)\n    }\n}"]}],["$","p",null,{"children":[["$","q","0",{"children":["下一个排列"]}]," ","问题是少有的命令式程序可以比函数式程序简洁的问题。甚至，Haskell"," ","的"," ",["$","a","1",{"href":"https://hackage.haskell.org/package/permutation-0.5.0.5/docs/Data-Permute.html","children":["Data.Permute"]}]," ","库，也用了命令式的方法。"]}],["$","p",null,{"children":["在命令式程序中，上面的算法可以被描述为两个过程："]}],["$","ol","101",{"children":[["$","li","0",{"children":["从右向左遍历，找到最长的下降序列"," ",["$","span",null,{"data-testid":"react-katex","dangerouslySetInnerHTML":{"__html":"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>…</mo><mo stretchy=\"false\">(</mo><mtext>len - 1</mtext><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">a[i \\dots (\\text{len - 1})]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord\">len - 1</span></span><span class=\"mclose\">)]</span></span></span></span>"}}]]}],["$","li","1",{"children":["进行计算，",["$","ul","0",{"children":[["$","li","0",{"children":[["$","p",null,{"children":["如果"," ",["$","span",null,{"data-testid":"react-katex","dangerouslySetInnerHTML":{"__html":"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">i = 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>"}}],"，那么反转数组"]}]]}],["$","li","1",{"children":[["$","p",null,{"children":["其他情况，找到"," ",["$","span",null,{"data-testid":"react-katex","dangerouslySetInnerHTML":{"__html":"$7"}}],"，使得"]}],["$","ul","1",{"children":[["$","li","0",{"children":[["$","span",null,{"data-testid":"react-katex","dangerouslySetInnerHTML":{"__html":"$8"}}]]}],["$","li","1",{"children":[["$","span",null,{"data-testid":"react-katex","dangerouslySetInnerHTML":{"__html":"$9"}}]]}]]}],["$","p",null,{"children":["交换"," ",["$","span",null,{"data-testid":"react-katex","dangerouslySetInnerHTML":{"__html":"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">i - 1, j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7429em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.854em;vertical-align:-0.1944em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span></span></span></span>"}}],"，反转"," ",["$","span",null,{"data-testid":"react-katex","dangerouslySetInnerHTML":{"__html":"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>…</mo><mo stretchy=\"false\">(</mo><mtext>len - 1</mtext><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">a[i \\dots (\\text{len - 1})]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord\">len - 1</span></span><span class=\"mclose\">)]</span></span></span></span>"}}]]}]]}]]}]]}]]}],["$","p",null,{"children":["如果读者完全理解了上面的函数式算法，这个命令式算法想必是非常直白的。但如果把这个算法直接端到你的面前喂给你，你真的能明白它为什么是正确的吗？"]}],["$","p",null,{"children":["让我们用一个"," ","Python"," ","程序结束今天的故事吧！"]}],["$","$L6","104",{"className":"python","children":["def swap(a, i, j):\n    tmp = a[i]\n    a[i] = a[j]\n    a[j] = tmp\n\ndef rev(a, start, end):\n    l = end - start\n    for i in range(start, start + l // 2):\n        swap(a, i, end - (i - start) - 1)\n\ndef solve(a):\n    for i in range(len(a) - 1, -1, -1):\n        if i >= 1 and a[i - 1] < a[i]:\n            break\n    if i == 0:\n        rev(a, 0, len(a))\n    else:\n        j = len(a) - 1\n        while j >= i and a[j] <= a[i - 1]:\n            j -= 1\n        swap(a, i - 1, j)\n        rev(a, i, len(a))"]}],["$","div",null,{"className":"notes","children":[["$","$La",null,{"itemId":"1","id":"note-1","children":[["$","p",null,{"children":["注意这不是精确的描述，Haskell"," ","是惰性的，求值过程需要仔细分析"]}]]}]]}]]}]]}]],null],null]},[["$","div",null,{"className":" relative w-full px-6 py-12 shadow-xl  shadow-slate-700/20 ring-1 ring-gray-900/5 dark:shadow-slate-100/20 dark:ring-gray-100/5 md:max-w-3xl md:mx-auto lg:max-w-4xl lg:pt-16 lg:pb-28 prose prose-natural dark:prose-invert","children":["$","div",null,{"className":"px-2","children":["$","$Lb",null,{"parallelRouterKey":"children","segmentPath":["children","$c","children","posts","children","$d","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$Le",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/ecc949282143a457.css","precedence":"next","crossOrigin":"$undefined"}]]}]}]}],null],null]},["$","$Lb",null,{"parallelRouterKey":"children","segmentPath":["children","$c","children","posts","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$Le",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}],null]},[["$","html",null,{"lang":"zh-cn","suppressHydrationWarning":true,"children":["$","body",null,{"className":"text-foreground bg-background min-h-screen","children":["$","$Lf",null,{"children":["$L10",["$","$Lb",null,{"parallelRouterKey":"children","segmentPath":["children","$c","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$Le",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}]]}]}]}],null],null]},[["$","$Lb",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$Le",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"styles":[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/ffccf689a8f498ba.css","precedence":"next","crossOrigin":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"/_next/static/css/ad2762ca96cee671.css","precedence":"next","crossOrigin":"$undefined"}]]}],null],null],[null,"$L11"]]]]
12:I[53693,["706","static/chunks/706-97ed238ee5a03fb5.js","469","static/chunks/469-7ee2e4c850f58403.js","911","static/chunks/911-e9f556f9b03e931c.js","373","static/chunks/373-fbdb9516436dc720.js","203","static/chunks/app/%5Blocale%5D/layout-a565b40c48425316.js"],"Navbar"]
13:I[53693,["706","static/chunks/706-97ed238ee5a03fb5.js","469","static/chunks/469-7ee2e4c850f58403.js","911","static/chunks/911-e9f556f9b03e931c.js","373","static/chunks/373-fbdb9516436dc720.js","203","static/chunks/app/%5Blocale%5D/layout-a565b40c48425316.js"],"NavbarBrand"]
15:I[53693,["706","static/chunks/706-97ed238ee5a03fb5.js","469","static/chunks/469-7ee2e4c850f58403.js","911","static/chunks/911-e9f556f9b03e931c.js","373","static/chunks/373-fbdb9516436dc720.js","203","static/chunks/app/%5Blocale%5D/layout-a565b40c48425316.js"],"NavbarItem"]
18:I[53693,["706","static/chunks/706-97ed238ee5a03fb5.js","469","static/chunks/469-7ee2e4c850f58403.js","911","static/chunks/911-e9f556f9b03e931c.js","373","static/chunks/373-fbdb9516436dc720.js","203","static/chunks/app/%5Blocale%5D/layout-a565b40c48425316.js"],"NavbarContent"]
19:I[81946,["706","static/chunks/706-97ed238ee5a03fb5.js","469","static/chunks/469-7ee2e4c850f58403.js","911","static/chunks/911-e9f556f9b03e931c.js","373","static/chunks/373-fbdb9516436dc720.js","203","static/chunks/app/%5Blocale%5D/layout-a565b40c48425316.js"],"default"]
1a:I[48125,["706","static/chunks/706-97ed238ee5a03fb5.js","469","static/chunks/469-7ee2e4c850f58403.js","911","static/chunks/911-e9f556f9b03e931c.js","373","static/chunks/373-fbdb9516436dc720.js","203","static/chunks/app/%5Blocale%5D/layout-a565b40c48425316.js"],"default"]
10:["$","$L12",null,{"shouldHideOnScroll":true,"children":[["$","$L13",null,{"className":"flex flex-row gap-4","children":[["$","p",null,{"className":"font-bold text-inherit","children":"$L14"}],["$","$L15",null,{"children":"$L16"}],["$","$L15",null,{"children":"$L17"}]]}],["$","$L18",null,{"justify":"end","className":"gap-1","children":[["$","$L15",null,{"children":["$","$L19",null,{}]}],["$","$L15",null,{"children":["$","$L1a",null,{}]}]]}]]}]
11:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"Aya's Blog"}],["$","meta","3",{"name":"description","content":"A site powered by next.js and pandoc"}],["$","link","4",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"48x48"}]]
1:null
1b:I[9678,["706","static/chunks/706-97ed238ee5a03fb5.js","469","static/chunks/469-7ee2e4c850f58403.js","911","static/chunks/911-e9f556f9b03e931c.js","373","static/chunks/373-fbdb9516436dc720.js","203","static/chunks/app/%5Blocale%5D/layout-a565b40c48425316.js"],"default"]
14:["$","$L1b",null,{"locale":"zh-cn","localePrefix":"always","href":"/","aria-label":"主页","children":"主页"}]
16:["$","$L1b",null,{"locale":"zh-cn","localePrefix":"always","href":"/blog/","className":"font-bold","aria-label":"博客","children":"博客"}]
17:["$","$L1b",null,{"locale":"zh-cn","localePrefix":"always","href":"/favorites/","className":"font-bold","aria-label":"园地","children":"园地"}]
